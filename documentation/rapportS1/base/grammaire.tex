Trouver une grammaire riche, complète et accessible à n'importe quel utilisateur est difficile.
C'est pourquoi, deux grammaires sont présentées.\note{il faut dire pourquoi on fait 2 grammaires.}

\begin{itemize}
 \item La première est dite de 'haut-niveau'.
Elle permet de décrire la majorité du contenu du jeu dans un langage simple et accessible pour les non-programmeurs.
 \item La seconde est dite de 'bas-niveau'.
Elle permet de manipuler chaque attribut et est beaucoup plus proche de l'implémentation finale que la première grammaire.
C'est par exemple elle qui permettra de définir le comportement de l'intelligence artificielle, chose très difficile à mettre en œuvre dans la grammaire de haut-niveau.
\end{itemize}

Le schéma de compilation se complexifie alors : un fichier décrivant le jeu dans la grammaire de haut-niveau est compilé afin de donner un fichier
respectant la grammaire de bas-niveau. A ce niveau-là, l'utilisateur peut effectuer de nouveaux ajouts ou modifications. Le second compilateur
produit alors le script final du jeu en JavaScript.

\subsection{Grammaire haut-niveau}

La description du jeu se déroule en plusieurs phases.
On peut spécifier au début les attributs du jeu puis déclarer ses entités : personnages, véhicules... et leurs attributs. 
Viennent ensuite les définitions d'actions de base et des commandes.
Enfin, les règles du jeu sont spécifiées.
Il est possible d'ajouter une intelligence artificielle (IA) basique, utilisant les entités et les actions déjà définies.

\subsubsection{Attributs du jeu}

Les attributs du jeu sont gérés principalement par les entités dans la grammaire haut-niveau, ce n'est donc pas obligatoire 
de préciser cette partie lors de l'écriture du code. Cependant il peut être plus rapide d'en définir directement ici :
\code{game has gravity at 9.81}.

\subsubsection{Définition des entités du jeu et de leurs attributs}

Il s'agit de lister les différents personnages ou objets qui apparaissent dans le jeu.
Pour faciliter le travail de l'utilisateur, diverses classes sont déjà créées pour définir les entités.
La classe de base est la classe Object avec des attributs de base comme la position, l'orientation, la taille, etc.
De celle-ci héritent de nombreuses autres classes comme Character, Vehicle ou Weapon, chacunes ayant de nouveaux attributs spécifiques.
\note{INCLURE LE SCHEMA DES CLASSES, au moins en annexe}

La déclaration d'une nouvelle entité se fait alors via un identificateur et le mot-clef 'is'.
Par exemple \code{Mario is Character} permet de déclarer Mario comme un personnage de classe Character, 
et peut donc posséder tous les attributs de cette classe. Ces derniers sont initialisés à des valeurs par défaut.
L'utilisateur peut les modifier. Par exemple, pour changer l'attribut \code{lifeMax} de Mario, 
représentant le niveau le plus haut possible de son attribut \code{life} les mots-clés 'has' et 'at' sont utilisés : 
\code{Mario has lifeMax at 3}.
De même, il est nécessaire de pouvoir rajouter de nouveaux attributs.
La syntaxe est la même. Ainsi, \code{Mario has energie at 8} ajoute un attribut energie (qui n'existe pas déjà dans Character) à Mario,
 initialisé à 8.
Les nouveaux attributs doivent obligatoirement être initialisés avec 'at'.

De plus, s'il existe divers personnages qui possèdent aussi cette énergie, il est souhaitable de ne pas avoir à répéter cette ligne.
Ainsi, de nouveaux types peuvent être créés grâce au mot-clef 'type' :
\code{type Plombier is Character. Plombier has energie at 8. Mario is Plombier. Luigi is Plombier.}
L'héritage multiple est possible ainsi que l'héritage de nouveaux types déclarés par l'utilisateur. Il suffira d'écrire :
\code{type BillBall is Character and Projectile.} \code{ type ennemiDangereux is BillBall}
Si un nouveau type ou objet est fils de plusieurs classes ayant un même attribut, ils sont fusionnés en un seul.

Ensuite, en même temps que la déclaration de la classe d'une nouvelle identité, il est possible de la définir comme commandée par le joueur, ennemie, alliée ou neutre.
Si rien n'est précisé, la valeur est mise à neutre par défaut.
\code{Mario is Plombier player. Luigi is Plombier ally. type Boss is Character ennemy.} \code{ Bowser is Boss.}
De plus, dans le cas où ce n'est pas un personnage joué, il peut être déclaré comme multiple.
Cela signifie qu'il est possible d'en générer plusieurs avec la seule commande 'generate'.
Par exemple \code{Koopa is} \code{Character enemy multiple. generate 5 Koopa in zone}. 
Permet de créer 5 Koopa dans \code{zone} qui aura été définie auparavant : \code{zone is Zone}. 
Outre 'in' qui est associé aux objets de type Zone, le mot-clef 'on' permet de placer 
des objets juste au-dessus de l'objet défini : \code{generate Mario on Luigi}, et le mot-clef 'at' génère
le premier objet à l'endroit indiqué et les autres autour de celui-ci, en évitant les collisions.

Enfin, il est possible de manipuler des listes.
\begin{lstlisting}[language=GameGrammar]
type humain is Character. 
aragorn is humain player.
boromir is humain.
type elfe is Character. 
legolas is elfe.
type nain is Character.
gimli is nain.
type hobbit is Character multiple. 
type magicien is Character. 
gandalf is magicien.
CommunauteDeLAnneau is list of aragorn with legolas with gimli with aragorn with boromir with gandalf with 4 hobbit.}
\end{lstlisting}

\subsubsection{Autres classes prédéfinies}

D'autres classes sont prédéfinies : une classe Game concernant l'ensemble général du jeu, une classe Camera contenant les informations sur les caméras :
certains comportements classiques sont prédéfinies comme une caméra libre ou bien un suivi à la première ou troisième personne.

De plus, 2 classes permettent de gérer respectivement les compteurs et les ressources de type temporel.

Enfin, une dernière classe permet de gérer les fichiers multimédias tel que les sons ou les vidéos qui peuvent intervenir au cours d'un jeu 
avec la possibilité de les jouer, de les arrêter, de les mettre en pause, d'activer le mode muet ainsi que de définir s'ils seront joués 
une fois pour des sons (mot-clef 'once'), ou en boucle (mot-clef 'loop') pour des musiques par exemple.

\subsubsection{Définition de nouvelles actions et assignation des commandes}

Il est ensuite possible de définir de nouvelles actions via le mot-clef 'definition' et 'means'.
Par exemple, en reprenant l'exemple de Mario : \code{Mario is Character player. definition sursautMario means mario jump.}
Les commandes sont ensuite définies après le mot-clef 'command'. Elles sont générées soit par l'appui d'une touche X du clavier ('key X') soit par 
une action Y sur la souris ('mouse Y').
\code{command mouse rClick for sursautMario} permet par exemple de causer l'action nommée sursautMario lorsque le joueur clique sur le bouton droit de la souris.

De plus, de nombreuses actions sont prédéfinies (pour les personnages notamment) comme jump ou move left ; ou concernant le jeu en général comme pause, save ou victory.
\code{command mario is key space for jump,} \code{ key Z for move forward, key Y for move backward, key S for move left, key D for move right.}

Il est possible de désactiver (respectivement d'activer) certaines touches du clavier ou action de la souris au cours du jeu.
Pour cela, il faut utiliser le mot-clef 'disable' (respectivement 'activate').
\code{disable key Z} désactive les actions lors de l'appui sur la touche Z.
Il est également possible de désactiver toutes les commandes \code{disable commands}, seulement celles du clavier \code{disable keyboard} ou celles de la souris \code{disable mouse}.

\subsubsection{Déclaration des règles du jeu}

Les règles du jeu sont définies par le mot-clef 'rule' et 'then'.
Par exemple \code{rule mario dies then defeat}.
'mario dies' est un déclencheur et 'defeat' est une conséquence.
Il ne peut y avoir qu'un déclencheur dans la règle mais il peut y avoir plusieurs conséquences.
La suite de conséquences s'exécute séquentiellement tandis que chaque règle est appelée en parallèle.
\note{Problème lié au parallélisme, si on change 2 fois des variables en même temps ... faudrait préciser le concept du parallèle 
ou n'autoriser que certains trucs en parallèle comme les médias, mais dans ce cas autant trouver une syntaxe dans une seule règle}

Il est également possible de manipuler les attributs des différentes entités. Prenons le cas où un ennemi a été défini \code{bowser is Character ennemy}.
Si mario entre en collision avec lui, il perd un point de vie, réduit son score de 100 et provoque un saut :
\code{rule mario touches bowser then sub 1 for life of} \code{ mario, sub 100 for score of game, mario jump}.

Avec 'sub', d'autres mots-clés existent pour les autres opérations arithmétiques élémentaires, ainsi qu'un 'assign' qui change directement
la valeur de l'attribut.
Il est également possible d'exécuter des actions seulement sous certaines conditions avec un 'If ... then ... else ... endIf'.

Certains concepts sont déjà définis : ainsi 'touches' est causé par une entrée en collision entre les deux entités. 'dies' signifie l'arrivée de l'attribut
'life' à 0 pour un objet de type Character, 'kills' se produit lorsque le premier personnage tue le second.

\subsubsection{IA}

Une IA basique peut être créée à partir des éléments déjà existants et définis lors des lignes de codes précédentes. 
La grammaire haut-niveau ne permet en aucun cas de créer une IA améliorée à moins d'écrire un nombre important de lignes de code. 
Mais là encore, les possibilitées resteraient limitées. Voici un exemple : 
\begin{lstlisting}[language=GameGrammar]
ia superGoomba is 
	move left during 2 sec
	jump
	move right during 2 sec
	jump
\end{lstlisting}

\subsubsection{Exemple de mini-jeu décrit dans la grammaire 'haut-niveau'}

Voici un exemple de code utilisant la grammaire haut-niveau.
Supposons que l'utilisateur crée un mini-jeu avec les éléments suivants :
\begin{itemize}
\item des représentation en 3D d'un shériff 'sheriff.obj', d'un zombie 'zombie.obj', d'une pièce de monnaie 'piece.obj'
\item d'un sol 
\item d'un volume englobant représentant une zone d'arrivée
\item d'une musique nommée 'musiqueAngoissante.mp3' et de deux musiques de fin 'musiqueVictoire.mp3' et 'musiqueDefaite.mp3'
\end{itemize}

Le but est, pour un shériff contrôlé par le joueur, d'éviter tous les zombies et de récupérer toutes les pièces d'or 
sur la carte. 
Il gagne lorsque toutes les pièces d'or ont été ramassées et qu'il se place sur la zone d'arrivée.
S'il parvient à la ligne d'arrivée avant d'avoir récupéré toutes les pièces, une nouvelle nuée de zombies affamés apparaît.
Il perd lorsqu'un zombie parvient à le toucher.

\begin{lstlisting}[language=GameGrammar]
game has score at 0.

cam1 is Camera free.         //free is not necessary because it is the default behavior for a camera

sol is Ground.

zombie is Character enemy multiple. 
zombie has attack at 1.                 //if a zombie touche the player, he loses one life

sheriff is Character player.
sheriff has life at 1.                  //he has only 1 life, so, at the first shot, he dies
sheriff has position at 0 300 0.

piece is Bonus multiple.
piece has value at 10.
piece has collectors at sheriff.        // the only character able to collect the bonus

arrivee is Zone.
arrivee has position at 300 500 0.

musiqueAngoissante is media loop.
musiqueVictoire is media once.
musiqueDefaite is media once.


definition generer10Zombies means
	generate 9 zombie on sol,    //10 new zombies are generated
	generate 1 zombie in zone.     //1 more in the zone where the player is


command sheriff is 
	space for jump,
	key Z for move forward, 
	key S for move backward, 
	key Q for move left,
	key D for move right.

command key P for pause.

command key enter for generer10Zombies.    //for more challenge


rule game starts then 
	generate sol,
	generate 30 zombie on sol,
	generate 10 piece on sol,
	generate sheriff,
	play musiqueAngoissante.

rule sheriff touches arrivee then 
	if score of game = 100 then 
		play musiqueVictoire,
		victory
	else generer10Zombies
	endIf.

rule zombie touches sheriff then 
	sheriff dies,
	play musiqueDefaite,
	defeat.



\end{lstlisting}

\subsection{Grammaire bas-niveau}

La grammaire bas-niveau est beaucoup plus proche de l'implémentation finale que la haut-niveau.
Ainsi, toutes les ressources doivent avoir un identifiant unique. Les évènements, qu'ils proviennent du joueur (clavier, souris) ou de la modification
de l'état d'un personnage sont gérés par des signaux.
La description d'un jeu est constituée de ressources, d'entités, de caméra, d'une boucle de rafraîchissement, d'un gestionnaire d'évènements.
Un moteur physique permettant de tester les collisions et contenant également les forces générales du jeu (gravitation, vent, etc) est également disponible.

\subsubsection{Définition des ressources}

Une ressource est une variable du jeu.
Elle est identifiée par un nom unique.

\code{marioLife 1} permet de créer une ressource marioLife initialisée à 1.

Il existe un type spécial de ressource : les ressources temporelles.
Celles-ci sont mises à jour via la boucle de rafraîchissement générale du jeu.
Pour la définir, cette fois 2 valeurs sont données suite à la ressource : le pas du timer, et son initialisation :
\code{timeStarBonus 10000 0} permet de créer une ressource de nom 'timerStarBonus' (pouvant correspondre à la durée du bonus donnée par une étoile)
avec un pas de 10 secondes et initialisée à 0 millisecondes. 

Il est également possible de faire des énumérations de ressources.
\note{il faudrait un joli exemple}

\subsubsection{Définition des entités et caméras}

On considère que le terrain est représenté, par exemple, par une matrice de points dans l'espace sur laquelle est appliquée une texture.
La matrice pourra être remplacée selon le type de terrain pour un certain jeu. \note{Ca veut un peut rien dire ça, non ?}

L'ensemble des entités d'un jeu est alors constitué d'un terrain et d'un ensemble d'objet.
Chaque objet est identifié par un nom, ainsi que par deux fichiers créés par des outils de dessin d'objets 3D, un fichier .obj contenant l'ensemble
des points de l'objet, et un fichier .mat contenant la texture appliquée sur les faces de l'objet.
De plus chaque objet contient un ensemble de paramètre comme la vitesse, la position, etc. \note{vérifier le format de sortie de Sketchup}

Les caméras sont définies de manière similaire aux entités : chaque caméra est définie par un nom, une position et une orientation.

\subsubsection{Boucle de rafraîchissement et gestionnaire d'évènements}

Les divers évènements du jeu sont gérés via un système de signaux.

Le jeu dispose d'une boucle de rafraîchissement principale. Celle-ci génère un signal
signalUpdateCounter émettant un signal régulièrement.
De même, il permet de vérifier les touches enfoncées et actions de la souris à chaque tic du timer.

Enfin, chaque mise à jour de ressource nommée X émet un signal updateX.

Les actions lors de la réception d'un signal sont gérées par un gestionnaire d'évènements.
Ce dernier est défini par un ensemble de signaux et d'instructions.
Les instructions sont données comme dans un langage classique.
Elles sont composées des mises à jours de variables en utilisant les opérateurs arithmétiques classiques, les constantes, les autres ressources et des nombres
aléatoires.
Des instructions conditionnelles sont également disponibles, les booléens étant générés via des comparaisons d'expressions.

Les instructions peuvent également reprendre des concepts classiques de mini-jeux : pause, nouvelle partie, fin de partie, sauvegarde de la partie.
\note{insérer un petit exemple}

\subsubsection{Exemple de mini-jeu dans la grammaire bas-niveau}

\note{to do ...}

\subsection{Avantages et limites de ces langages}

\note{cherche inspiration ...}